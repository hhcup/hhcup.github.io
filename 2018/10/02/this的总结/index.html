<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录和分享知识"><title>js数据类型及转换问题 | steak</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">js数据类型及转换问题</h1><a id="logo" href="/.">steak</a><p class="description">steak的个人博客</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">js数据类型及转换问题</h1><div class="post-meta">Oct 2, 2018</div><div class="post-content"><pre><code>在学习javascript中，我常常遇到this这个神奇的东西。在刚开始的时候，通过网上搜索
和一些demo的练习，我认为this的指向问题并不复杂，通常是谁调用即指向谁，在定时器
中指向全局对象window，在箭头函数中指向父级。但随着后来的学习我发现this的指向规
则不仅于此，在不同的情况下this的指向也会有很大的不同，在参考了《你不知道的java
script》一书后，我归纳总结了以下关于this的知识</code></pre><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="1-this的作用"><a href="#1-this的作用" class="headerlink" title="1.this的作用"></a>1.this的作用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify.call( <span class="keyword">this</span> );</span><br><span class="line">    <span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">    name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">    name: <span class="string">"Reader"</span></span><br><span class="line">&#125;;</span><br><span class="line">identify.call( me ); <span class="comment">// KYLE</span></span><br><span class="line">identify.call( you ); <span class="comment">// READER</span></span><br><span class="line">speak.call( me ); <span class="comment">// Hello, 我是 KYLE</span></span><br><span class="line">speak.call( you ); <span class="comment">// Hello, 我是 READER</span></span><br></pre></td></tr></table></figure>

<p>如果不使用 this ，那就需要给 identify() 和 speak() 显式传入一个上下文对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify( context );</span><br><span class="line">    <span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line">identify( you ); <span class="comment">// READER</span></span><br><span class="line">speak( me ); <span class="comment">//hello, 我是 KYLE</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>然而， this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将<br>API 设计得更加简洁并且易于复用。</p>
<h2 id="2-this的误解"><a href="#2-this的误解" class="headerlink" title="2.this的误解"></a>2.this的误解</h2></li>
<li><h3 id="1-this指向自身"><a href="#1-this指向自身" class="headerlink" title="1.this指向自身"></a>1.this指向自身</h3><h3 id="数指向自身在某些场景下是适用的，但某些场景并不适用。"><a href="#数指向自身在某些场景下是适用的，但某些场景并不适用。" class="headerlink" title="数指向自身在某些场景下是适用的，但某些场景并不适用。"></a>数指向自身在某些场景下是适用的，但某些场景并不适用。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line">    <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>console.log 语句产生了 4 条输出，证明 foo(..) 确实被调用了 4 次，<br>但是 foo.count 仍然是 0。显然从字面意思来理解 this 是错误的。</p>
</li>
<li><p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count 。<br>但是函数内部代码this.count 中的 this 并不是指向那个函数对象，所以<br>虽然属性名相同，根对象却并不相同,这是因为这段代码在无意中创建了一<br>个全局变量 count它的值为 NaN 。</p>
</li>
</ul>
<hr>
<h5 id="如果要从函数对象内部引用它自身，那只使用-this-是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。"><a href="#如果要从函数对象内部引用它自身，那只使用-this-是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。" class="headerlink" title="如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。"></a>如果要从函数对象内部引用它自身，那只使用 this 是不够的。一般来说你需要通过一个指向函数对象的词法标识符（变量）来引用它。</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo.count = <span class="number">4</span>; <span class="comment">// foo 指向它自身</span></span><br><span class="line">&#125;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 匿名（没有名字的）函数无法指向自身</span></span><br><span class="line">&#125;, <span class="number">10</span> );</span><br></pre></td></tr></table></figure>

<p>第一个函数被称为具名函数，在它内部可以使用 foo 来引用自身。<br>但是在第二个例子中，传入 setTimeout(..) 的回调函数没有名<br>称标识符（这种函数被称为匿名函数），因此无法从函数内部引用<br>自身。</p>
<blockquote>
<p>还有一种传统的但是现在已经被弃用的用法，是使用<br>arguments.callee 来引用当前正在运行的函数对象。这是唯<br>一一种可以从匿名函数对象内部引用自身的方法。然而，更好的<br>方式是避免使用匿名函数，至少在需要自引用时使用具名函数<br>（表达式）。 arguments.callee 已经被弃用，不应该再使<br>用它。</p>
</blockquote>
<h5 id="另一种解决方法是使用-foo-标识符替代-this-来引用函数对象："><a href="#另一种解决方法是使用-foo-标识符替代-this-来引用函数对象：" class="headerlink" title="另一种解决方法是使用 foo 标识符替代 this 来引用函数对象："></a>另一种解决方法是使用 foo 标识符替代 this 来引用函数对象：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line">    <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">    foo.count++;</span><br><span class="line">&#125;</span><br><span class="line">    foo.count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        foo( i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而，这种方法同样回避了 this 的问题，并且完全依赖于变量 foo<br>  的词法作用域。</p>
</blockquote>
<h4 id="另一种方法是强制-this-指向-foo-函数对象："><a href="#另一种方法是强制-this-指向-foo-函数对象：" class="headerlink" title="另一种方法是强制 this 指向 foo 函数对象："></a>另一种方法是强制 this 指向 foo 函数对象：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line">    <span class="comment">// 记录 foo 被调用的次数</span></span><br><span class="line">    <span class="comment">// 注意，在当前的调用方式下（参见下方代码），this 确实指向 foo</span></span><br><span class="line">    <span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line">    foo.count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 call(..) 可以确保 this 指向函数对象 foo 本身</span></span><br><span class="line">        foo.call( foo, i );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="comment">// foo 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="2-this的作用域"><a href="#2-this的作用域" class="headerlink" title="2.this的作用域"></a>2.this的作用域</h2><ul>
<li>第二种常见的误解是， this 指向函数的作用域。这种说法也是片面的， this 在任何情<br>况下都不指向函数的词法作用域。</li>
<li>在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域<br>“对象”无法通过 JavaScript代码访问，它存在于 JavaScript 引擎内部。</li>
</ul>
<p>下面的代码，试图（但是没有成功）跨越边界，使用 this 来隐式引用函数的词法作用域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面的代码有两处错误：</p>
<ol>
<li>用this.bar() 来引用 bar() 函数。这是绝对不可能成功的，调用 bar() 最自然的方<br> 法是省略前面的 this ，直接使用词法引用标识符。</li>
<li>使用 this 联通 foo() 和 bar() 的词法作用域，从而让<br>bar() 可以访问 foo() 作用域里的变量 a 。这是不可能实现的，你不能使用 this 来引用<br>一个词法作用域内部的东西。</li>
</ol>
<hr>
<h1 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h1><ul>
<li>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调<br>用时的各种条件。 this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</li>
<li>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包<br>含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。 this 就是记录的<br>其中一个属性，会在函数执行的过程中用到。</li>
<li>每个函数的 this 是在调用<br>时被绑定的，完全取决于函数的调用位置（也就是函数的调用方法）。</li>
</ul>
<h2 id="1-调用位置"><a href="#1-调用位置" class="headerlink" title="1.调用位置"></a>1.调用位置</h2><ul>
<li><p>在理解 this 的绑定过程之前，首先要理解调用位置：调用位置就是函数在代码中被调用的<br>位置（而不是声明的位置）。只有仔细分析调用位置才能回答这个问题：这个 this 到底引<br>用的是什么？</p>
</li>
<li><p>通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，<br>因为某些编程模式可能会隐藏真正的调用位置。</p>
</li>
<li><p>最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）我们关心的调用<br>位置就在当前正在执行的函数的前一个调用中。</p>
<p>  下面我们来看看到底什么是调用栈和调用位置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前调用栈是：baz</span></span><br><span class="line"><span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"baz"</span> );</span><br><span class="line">bar(); <span class="comment">// &lt;-- bar 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是 baz -&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在 baz 中</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</span><br><span class="line">    foo(); <span class="comment">// &lt;-- foo 的调用位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在 bar 中</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="comment">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="2-绑定规则"><a href="#2-绑定规则" class="headerlink" title="2.绑定规则"></a>2.绑定规则</h2><h3 id="函数的执行过程中调用位置如何决定-this-的绑定对象？"><a href="#函数的执行过程中调用位置如何决定-this-的绑定对象？" class="headerlink" title="函数的执行过程中调用位置如何决定 this 的绑定对象？"></a>函数的执行过程中调用位置如何决定 this 的绑定对象？</h3><p>1.必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。</p>
<h3 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1.默认绑定"></a>1.默认绑定</h3><h4 id="首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。"><a href="#首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。" class="headerlink" title="首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。"></a>首先要介绍的是最常用的函数调用类型：独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。</h4><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></code></pre><ul>
<li>1.应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2 ）就是全局对象<br>的一个同名属性。</li>
<li>2.当调用 foo() 时， this.a 被解析成了全局变量 a 。因为函数调用时应用了 this 的<br>默认绑定，因此 this 指向全局对象。</li>
<li>3.那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调<br>用的。在代码中， foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用<br>默认绑定，无法应用其他规则</li>
</ul>
<blockquote>
<h4 id="如果使用严格模式（-strict-mode-），那么全局对象将无法使用默认绑定，因此-this-会绑定到-undefined-："><a href="#如果使用严格模式（-strict-mode-），那么全局对象将无法使用默认绑定，因此-this-会绑定到-undefined-：" class="headerlink" title="如果使用严格模式（ strict mode ），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined ："></a>如果使用严格模式（ strict mode ），那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined ：</h4></blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="这里有一个微妙但是非常重要的细节，虽然-this-的绑定规则完全取决于调用位置，但是只有-foo-运行在非-strict-mode-下时，默认绑定才能绑定到全局对象；严格模式下与-foo-的调用位置无关"><a href="#这里有一个微妙但是非常重要的细节，虽然-this-的绑定规则完全取决于调用位置，但是只有-foo-运行在非-strict-mode-下时，默认绑定才能绑定到全局对象；严格模式下与-foo-的调用位置无关" class="headerlink" title="这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()的调用位置无关:"></a>这里有一个微妙但是非常重要的细节，虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象；严格模式下与 foo()的调用位置无关:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    foo();  == &gt;  <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2.隐式绑定"></a>2.隐式绑定</h2><h4 id="另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。"><a href="#另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。" class="headerlink" title="另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。"></a>另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含，不过这种说法可能会造成一些误导。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1.首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。<br>但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于<br>obj 对象。</li>
<li>2.然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“<br>拥有”或者“包含”它。</li>
<li>3.无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数<br>引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调<br>用 foo() 时 this 被绑定到 obj ，因此 this.a 和 obj.a 是一样的。<h4 id="对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说："><a href="#对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：" class="headerlink" title="对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说："></a>对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">console.log( this.a );</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">obj2</span> = <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    a: 42,</span></span></span><br><span class="line"><span class="function"><span class="comment">    foo: foo</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    a: 2,</span></span><br><span class="line"><span class="comment">    obj2: obj2</span></span><br><span class="line"><span class="comment">&#125;</span>;</span><br><span class="line">obj1.obj2.foo(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h3><h4 id="一个最常见的-this-绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把-this-绑定到全局对象或者-undefined-上，取决于是否是严格模式。"><a href="#一个最常见的-this-绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把-this-绑定到全局对象或者-undefined-上，取决于是否是严格模式。" class="headerlink" title="一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。"></a>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名！</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>

<h4 id="虽然-bar-是-obj-foo-的一个引用，但是实际上，它引用的是-foo-函数本身，因此此时的bar-其实是一个不带任何修饰的函数调用，因此应用了默认绑定。"><a href="#虽然-bar-是-obj-foo-的一个引用，但是实际上，它引用的是-foo-函数本身，因此此时的bar-其实是一个不带任何修饰的函数调用，因此应用了默认绑定。" class="headerlink" title="虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。"></a>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</h4><h4 id="在传入回调函数时："><a href="#在传入回调函数时：" class="headerlink" title="在传入回调函数时："></a>在传入回调函数时：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// fn 其实引用的是 foo</span></span><br><span class="line">    fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">doFoo( obj.foo ); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure>

<h4 id="参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。"><a href="#参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。" class="headerlink" title="参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。"></a>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。</h4><h3 id="如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别："><a href="#如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：" class="headerlink" title="如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别："></a>如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">2</span>,</span><br><span class="line">    foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">setTimeout( obj.foo, <span class="number">100</span> ); <span class="comment">// "oops, global"</span></span><br><span class="line"></span><br><span class="line">JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setTimeout</span>(<span class="params">fn,delay</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 等待 delay 毫秒</span></span><br><span class="line">        fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="就像我们看到的那样，回调函数丢失-this-绑定是非常常见的。除此之外，还有一种情况-this-的行为会出乎我们意料：调用回调函数的函数可能会修改-this-。在一些流行的JavaScript-库中事件处理器常会把回调函数的-this-强制绑定到触发事件的-DOM-元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。"><a href="#就像我们看到的那样，回调函数丢失-this-绑定是非常常见的。除此之外，还有一种情况-this-的行为会出乎我们意料：调用回调函数的函数可能会修改-this-。在一些流行的JavaScript-库中事件处理器常会把回调函数的-this-强制绑定到触发事件的-DOM-元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。" class="headerlink" title="就像我们看到的那样，回调函数丢失 this 绑定是非常常见的。除此之外，还有一种情况 this 的行为会出乎我们意料：调用回调函数的函数可能会修改 this 。在一些流行的JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。"></a>就像我们看到的那样，回调函数丢失 this 绑定是非常常见的。除此之外，还有一种情况 this 的行为会出乎我们意料：调用回调函数的函数可能会修改 this 。在一些流行的JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。</h4><ul>
<li>无论是哪种情况， this 的改变都是意想不到的，实际上你无法控制回调函数的执行方式，</li>
<li>因此就没有办法控制会影响绑定的调用位置。可以通过固定 this 来修复</li>
</ul>
</blockquote>
<h2 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3.显式绑定"></a>3.显式绑定</h2><h4 id="在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把-this-间接（隐式）绑定到这个对象上。"><a href="#在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把-this-间接（隐式）绑定到这个对象上。" class="headerlink" title="在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。"></a>在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。</h4><ul>
<li><h3 id="如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数该怎么做呢？"><a href="#如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数该怎么做呢？" class="headerlink" title="如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数该怎么做呢？"></a>如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数该怎么做呢？</h3><h4 id="JavaScript-中的“所有”函数都有一些有用的特性（这和它们的-原型-有关），可以用来解决这个问题。具体点说，可以使用函数的-call-和apply-方法。严格来说，JavaScript-的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript-提供的绝大多数函数以及自己创建的所有函数都可以使用-call-和-apply-方法。"><a href="#JavaScript-中的“所有”函数都有一些有用的特性（这和它们的-原型-有关），可以用来解决这个问题。具体点说，可以使用函数的-call-和apply-方法。严格来说，JavaScript-的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript-提供的绝大多数函数以及自己创建的所有函数都可以使用-call-和-apply-方法。" class="headerlink" title="JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。"></a>JavaScript 中的“所有”函数都有一些有用的特性（这和它们的 [[ 原型 ]] 有关），可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。</h4>  它们的第一个参数是一个对象，它们会把这个对象绑定到this ，接着在调用函数时指定<br>  这个 this 。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br><span class="line">通过 foo.call(..) ，我们可以在调用 foo 时强制把它的 <span class="keyword">this</span> 绑定到 obj 上。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<h4 id="如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作-this-的绑定对象，这个原始值会被转换成它的对象形式（也就是-new-String-、-new-Boolean-或者new-Number-）。这通常被称为“装箱”。可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题-但是硬绑定可以解决这个问题。"><a href="#如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作-this-的绑定对象，这个原始值会被转换成它的对象形式（也就是-new-String-、-new-Boolean-或者new-Number-）。这通常被称为“装箱”。可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题-但是硬绑定可以解决这个问题。" class="headerlink" title="如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为“装箱”。可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题,但是硬绑定可以解决这个问题。"></a>如果传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..) 、 new Boolean(..) 或者new Number(..) ）。这通常被称为“装箱”。可惜，显式绑定仍然无法解决我们之前提出的丢失绑定问题,但是硬绑定可以解决这个问题。</h4></blockquote>
<h3 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h3></div><div class="tags"><a href="/tags/知识总结/">知识总结</a></div><div class="post-nav"><a class="next" href="/2018/08/01/js数据类型及转换/">js数据类型及转换问题</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/知识总结/" style="font-size: 15px;">知识总结</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/02/this的总结/">js数据类型及转换问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/01/js数据类型及转换/">js数据类型及转换问题</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">steak.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>